# 函数式组件

- 函数式组件其实一开始与类式组件是被react-一起推出的，但是因为函数式组件没有 state,也没有生命周期，所以导致其实际的应用价值一直都不如类组件，所以一直都无法被很好的推广开来，但是自从React16.8版本来实推出hook函数，其应用价值得到巨大提升，逐新被更多开发者青睐

- 函数式组件与类式组件的主要区别点：
- 1、函数式组件没有state，但是提供了很多的hook函数，然后函数式组件可以使用state，并且渲染数据更加简洁
- 2、没有this，因为函数内的this并不会指向函数自身，所以无法通过this调用自身的数据与方法
- 3、没有生命周期钩子函数，但是可以依靠hook函数来模拟新建一个Func.jsx

- > 可以安装一个VScode的插件 ES7 React/Redux/GraphQL/React-Nativesnippets 然后我们就可以通过 rcc和rfc 快捷生成一个类组件或函数组件

- ```jsx
  import React from 'react';
  export default function Func() {
      return (
          <div>
          </div>
      );
  }
  ```

  

- > 提问：
  >
  > 我们在组件内并没有调用React对象，那么为什么要导入React对象？（对之前内容的复习）
  >
  > 原因：
  >
  > 因为return中的div标签是react的虚拟标签，是需要通过React.createElement方法创建出来的，而这里我们并没有看到该方法的调用是因为JSX语法糖把这段通过JS代码执行创建的过程直接简化成了一个虚拟标签来表示

## 1、useState函数

- **功能**：useState可以在函数式组件中创建state状态进行使用
- **参数**：传入的实参会作为该组件的内部状态的值使用
- **返回值**：该方法返回一个数组，这个数组中包含两个数组元素，第一个是状态值，第二个是修改状态值的方法

- ```jsx
  import React, { useState } from 'react';
  export default function Func() {
      //通过数组解构取值的方式，分别取出useState返回的数组中的数组元素
      //num就是状态值
      //setNum就是修改状态值的方法
      const [num, setNum] = useState(10);
      //制作一个修改状态值的方法
      const changeNum = () => {
          setNum(num + 1);
      };
      return (
          <div>
              <h2>{num}</h2>
              <button onClick={changeNum}>按钮</button>
          </div>
      );
  }
  ```

  

- > 代码分析：
  >
  > 这里我们主要看解构取值的这句话，num里面装的是创建好的状态值，setNum里面状态的是修改num的方法，因为是数组解构，所以没有属性只有下标，上面的num和setNum可以自己定义名称
  >
  > 在虚拟标签中调用的时候，因为没有this，所以如果是渲染数据就直接调用即可，如果是调用方法，直接写方法名即可
  >
  > 补充：
  >
  > 如果我们不想专门生命一个方法来调用setNum，可以直接在onClick事件中绑定一个匿名函数
  >
  > ```jsx
  > <button onClick={() => setNum(num + 1)}>按钮</button>
  > ```
  >
  > 注意点：
  >
  > useState函数只能在组件内的最外层使用，比如，我们如果像做一个if判断决定是否执行useState，或者将useState写在函数式组件的某一个方法内的话是会报错的（不要在组件内部的{ }内调用useState）

### 1.1、函数式组件通信（父子传值）

- 在Func.jsx中再创建一个函数式组件Child，实现父传子

- ```jsx
  import React, { useState } from 'react';
  //创建子组件Child设置形参props接收父组件传入的数据与方法
  function Child(props) {
      return (
          <>
              <h2>{props.num}</h2>
              <button onClick={props.changeNum}>按钮</button>
          </>
      );
  }
  export default function Func() {
      const [num, setNum] = useState(10);
      const changeNum = () => {
          setNum(num + 1);
      };
      return (
          <div>
              {/* <h2>{num}</h2>
  <button onClick={() => setNum(num + 1)}>按钮</button>
  */}
              <Child num={num} changeNum={changeNum}></Child>
          </div>
      );
  }
  ```

  - > 代码分析：
    >
    > 父子传值的方式与之前的类组件的逻辑基本一样，所有传入到子组件中的数据与方法都可以在子组件的props中调出使用，只不过现在必须要在函数式组件的参数中设置形参props

### 1.2、使用带参的修改数据方法

- 现在我们想要实现通过调用changeNum传入一个实参，然后根据实参值来决定 num的修改结果，大致的代码示意如下：

- > **注意：以下写法会报错的，只是一个示意**

- ```jsx
  const changeNum = val => {
      setNum(num + val);
  };
  ```

- 报错信息：

- Too many re-renders.React limits the number of renders to prevent an infinite oop.

- 这里主要是说我们重复渲染的次数大多了成了一个无限循环

- > **可能的原因：**
  >
  > ```jsx
  > <button onClick={changeNum(10)}>按钮</button>
  > ```
  >
  > 原因就是出在调用changeNum的时候写在后面的小括号，首先，我们先明确两个点：
  >
  > 1、在React组件的标签结构中使用 { } 是用来执行JS语句
  >
  > 2、我们在调用函数的时候后面的写的小括号是一个函数的立即执行符
  >
  > 基于以上两点当浏览器开始渲染组件的时候，会对大括号内的JS语法进行执
  >
  > 行，而按照上面的写法，我们需要在调用函数的时候通过（）给函数传实参，
  >
  > 而也就是因为这个（），导致了现在实际上并不是把changeNum函数的函数体
  >
  > 赋值给click事件，等待点击之后执行
  >
  > 但是还没有等到点击，就已经开始执行setNum(num+val)这句话，而这里执行
  >
  > 的setNum方法，其内部是依靠setState方法来修改数据，而setState的修改状
  >
  > 态是一个异步操作，那么，就有可能出现一种情况，因为要修改的数据还没有
  >
  > 出现，找不到需要修改的数据，setState就会反复找组件要数据，导致组件被
  >
  > 反复渲染，而react对自己组件重复渲染的次数是有限制的，所以导致了报错

- **解决方法一：闭包函数**

- ```jsx
  //第一种闭包写法
  export default function Func() {
      const [num, setNum] = useState(10);
      const changeNum = val => setNum(num + val);
      return (
          <div>
              <h2>{num}</h2>
              <button onClick={() => changeNum(10)}>按钮</button>
          </div>
      );
  }
  ```

  - 然后，setNum因为其内部还是调用setState来实现的状态修改，所以setNum也可以直接传入一个回调函数来实现状态值的修改

  - setNum也可以传入一个回调`setNum(prev => prev + val)`，这个prev代表修改之前的num状态值

  - ```jsx
    //第二种闭包写法
    export default function Func() {
        const [num, setNum] = useState(10);
        const changeNum = val => {
            return () => setNum(prev => prev + val);
        };
        return (
            <div>
                <h2>{num}</h2>
                <button onClick={changeNum(10)}>按钮</button>
            </div>
        );
    }
    ```

    

- 两种闭包的写法，区别在于需要包在setNum外层的函数声明是写在标签结构的{ }里面，还是直接在组件内先声明好

- **解决方法二：通过bind方法**

```jsx
export default function Func() {
    const [num, setNum] = useState(10);
    const changeNum = val => setNum(num + val);
    return (
        <div>
            <h2>{num}</h2>
            <button onClick={changeNum.bind(this, 10)}>按钮
            </button>
        </div>
    );
}
```

- 第二种方案本质上也是一种闭包表现，因为bind会给原函数外再包装一层函数

## 2、useEffect函数

- 功能：useEffect函数的主要功能就两个
  - 1、用来模拟部分生命周期函数的效果
  - 2、监听数据变化
- 参数：useEffect接收两个参数
  - 参数1 - 回调函数：当useEffect作为监听器使用时，监听到某个状态值变化时执行
  - 参数2 - 数组：可以在数组中设置希望监听的状态

- > 注意：
  >
  > 该方法具备一定的特殊性，希望实现生命周期的模拟还时监听器的作用，可以
  >
  > 根据传入的参数来决定

### 2.1、useEffect函数的几种情况

- 1、作为监听器使用时，传入的第二个参数的数组中设置了具体要监听的状态，该监听会被立即执行

- 新建一个Effect.jsx

- ```jsx
  import React, { useState, useEffect } from 'react';
  export default function Effect() {
      const [num, setNum] = useState(10);
      const changeNum = () => {
          setNum(num + 1);
      };
      useEffect(() => {
          console.log("Effect被触发了");
      }, [num]);
      return (
          <div>
              <h2>{num}</h2>
              <button onClick={changeNum}>按钮</button>
          </div>
      );
  }
  ```

- > 代码分析：
  >
  > 这种情况下会在组件加载完毕之后立即执行监听，相当于vue3中的
  >
  > watchEffect，然后我们通过调用修改num的方法可以反复触发监听，但是如果
  >
  > 我们有其它数据因为没有在数组中设置，那么就无法监听

- 2、传入的第二个参数时一个空数组，表示没有监听任何状态，但是监听还是会立即执行一次，所以，这种情况下我们可以理解成是componentDidMount

- ```jsx
  import React, { useState, useEffect } from 'react';
  export default function Effect() {
      //......
      useEffect(() => {
          console.log("Effect被触发了");
      }, []);
      //......
  }
  ```

- > 情况分析：
  >
  > 因为情况1我们也说了useEffect作为监听器使用就和vue3中的watchEffect一样
  >
  > 的，无论是否监听到数据变化都会先执行一遍回调，所以，当我们什么都不监
  >
  > 听的时候，所立即执行的回调就可以当成挂载阶段的componentDidMount生
  >
  > 命周期来看待

- 3、不写第二个参数的数组，表示只要是useState生成的数据发生变化的时候就会执行回调，相当于监听组件中所有数据的变化，这种情况类以于生命周期中的更新阶段update

- ```jsx
  import React, { useState, useEffect } from 'react';
  export default function Effect() {
      //......
      useEffect(() => {
          console.log("Effect被触发了");
      });
      //......
  }
  ```

- > 情况分析：
  >
  > 数据发生了变化我们就可以理解成数据进行了更新，所以在这种情况下触发的
  >
  > 回调我们就可以当做是更新阶段执行的componentDidUpdate生命周期函数

- 4、在回调函数中再返回一个函数，这个返回的函数就相当于是组件卸载时执行的生命周期函数componentwillUnmount

- ```jsx
  import React, { useState, useEffect } from 'react';
  export default function Effect() {
      //......
      useEffect(() => {
          console.log("Effect被触发了");
          return () => {
              console.log("我被卸载了");
          };
      });
      //......
  }
  ```

- > 情况分析：
  >
  > 卸载阶段就只有一个生命周期函数，所以我们可以很明确的直接说明该回调函
  >
  > 数中return的函数就时componentWillUnmount

## 3、useContext函数

- 之前我们再类组件当中可以通过context上下文环境进行跨级传值，在函数式组件中，我们可以通过以下两个方法来实现
- 1、createContext 创建一个上下文环境空间
- 2、useContext 从创建好的上下文环境中获取数据
- 举例：
- 新建一个Context.jsx

```jsx
import React, { createContext, useContext, useState } from 'react';
//第一步：创建上下文环境空间，这个函数的执行会返回一个组件，所以我们的常量名会作为组件名使用，首字母大写;
const ContextMsg = createContext();
const Son = () => {
    //第三步：在后代组件中通过useContext从执行的上下文环境中调出数据使用
    const obj = useContext(ContextMsg);
    return (
        <>
            <h2>我是Son:{obj.userName},我今年{obj.age}岁</h2>
        </>
    );
};
export default function Context() {
    const [str, setStr] = useState({
        userName: "zhangsan",
        age: 18
    });
    return (
        //第二步：在父组件中调用上下文环境组件中的Provider提供器，通过其        value属性向上下文环境中提供数据
        < ContextMsg.Provider value={str} >
            <div>
                <Son></Son>
            </div>
        </ContextMsg.Provider>
    );
}
```

- > 代码分析：
  >
  > 上面实现Context跨级传值的逻辑大致分为以下几个步骤
  >
  > 1、通过createContext创建一个上下文环境空间，这个空间本质上是一个组
  >
  > 件，这个组件内部有一个和react-redux一样的一个提供器，我们通过向这个提
  >
  > 供器注入数据，从而让整个上下文环境中的后代组件都可以调用这个数据，这
  >
  > 个创建过程不能在组件内
  >
  > 2、在父组件的标签结构的最外层使用组件中的提供器，并通过该组件的value
  > 属性向上下文环境中传入数据
  > 3、在后代组件中通过useContext来获取父组件中传入上下文环境中的数据来
  > 进行调用
  > 除了通过useContext，还有另外一种获取上下文环境中数据的方式，这个在
  > 之前的类组件已经演示过，可以查看之前的笔记

### 3.1、将方法传入上下文进行传递

- 在上面的例子中我们将一个对象传入上下文环境，然后调用，即然能传对象，俺么，我们自然也可以在对象内设置方法，让方法随着对象一并传入到上下文环境中进行调用

- 举例：
- 现在在父组件中通过useState创建状态并解构获取状态值和修改状态的方法，现在我们把状态值和修改状态值的方法传入到上下文环境中，在不同的子组件中分别调用状态值和修改状态值的方法

```jsx
import React, { createContext, useContext, useState } from 'react';
//第一步：创建上下文环境空间，这个函数的执行会返回一个组件，所以我们的常量名会作
为组件名使用，首字母大写;
const ContextMsg = createContext();
export default function Context() {
    const [str, setStr] = useState({
        userName: "zhangsan",
        age: 18
    });
    return (
        //将状态和方法通过ES6的语法打包成一个匿名对象，传入到上下文环境中
        <ContextMsg.Provider value={{ str, setStr }}>
            <div>
                <Son></Son>
                <Btn></Btn>
            </div>
        </ContextMsg.Provider>
    );
}
//在Btn组件中调出方法修改原数据
const Son = () => {
    //第三步：在后代组件中通过useContext从执行的上下文环境中调出数据使用
    const { str } = useContext(ContextMsg);
    return (
        <>
            <h2>我是Son:{str.userName},我今年{str.age}岁</h2>
        </>
    );
};
const Btn = props => {
    const { str, setStr } = useContext(ContextMsg);
    return (
        <>
            <button onClick={() => setStr({
                ...str,
                userName: "lisi"
            })}>按钮</button>
        </>
    );
};
```

## 4、useReducer函数

- 这个函数名字中带有reducer，可能会让大家觉得是之前redux中的reducer函数，但是这里的useReducer并不时redux中的函数，所以于redux无关，但是它们的功能用法非常相似
- useReducer是一个数据管理器，于redux的功能基本一致，它可以接收两个参数

- **参数1**：一个回调函数，这个传入的回调函数其内部语法结构和作用，于我们之前在redux中学习的reducer函数一样
- **参数2：**传入一个对象，这个对象就是一个state状态对象，也就是需要管理的数据
- 举例

```jsx
import React, { useReducer } from 'react';
export default function Reducer() {
    //通过useReducer创建一个数据管理器，并把修改方法和需要管理的数据作为参数
    传入;
    //该方法会一个数组，我们通过解构取值获取到管理器中的数据state和派发修改欣慰的dispatch方法;
    let [state, dispatch] = useReducer(stateReducer, { num: 10 });
    //创建一个修改num的方法，在内创建一个行为action，并将该行为派发给数据管理
    器;
    const changeNum = () => {
        let action = {
            type: "num",
            value: 10
        };
        dispatch(action);
    };
    return (
        <div>
            <h2>{state.num}</h2>
            <button onClick={changeNum}>按钮</button>
        </div>
    );
}
//创建一个于redux中一样的根据dispatch派发的行为来决定如果修改数据的reducer方法;
//内部的语法结构于redux中的reducer导出的方法一样
const stateReducer = (state, action) => {
    let newState = JSON.parse(JSON.stringify(state));
    switch (action.type) {
        case "num":
            newState.num += action.value;
            break;
        default:
            break;
    }
    return newState;
};
```

- 以上你的代码，我们可以人为基本上整个过程就是在完全模仿redux的写法，所以作用用法都基本上是一样

- > 扩展：
  >
  > 即然都一样，为什么还要专门有一个useReducer，因为react的组件有一个特
  >
  > 点，它不像vue是一个文件就是一个组件，react的组件要不是一个类，要不是
  >
  > 一个函数，所以说，在react当中一个文件里面是可以创建多个组件的
  >
  > 那么，useReducer创建的数据管理器，我们可以认为就是针对一个文件中的所
  >
  > 有组件的一个文件内的“全局状态管理器”，这样在数据传递上面不需要专门做
  >
  > 成父子关系，只要在同一个里面，就可以实现数据互传

- 练习：

- > 使用useContext将被useReducer所管理的数据和派发修改行为的方法分别传递给两
  >
  > 个不同的子组件，来完成数据修改