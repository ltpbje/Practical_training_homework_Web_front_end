{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"76U77","children":{"0":{"objectClass":"MindNode","ID":"N10H1","children":{"0":{"objectClass":"MindNode","ID":"5DXR9","text":"目前来讲，我们有两种比较流程的软件开发思路，面向过程和面向对象"},"1":{"objectClass":"MindNode","ID":"DSE4V","children":{"0":{"objectClass":"MindNode","ID":"IL1NC","children":{"0":{"objectClass":"MindNode","ID":"52OT5","text":"var stu_xm = {\nname:\"小明\",\nage:20,\nsex:\"男\",\nhobby:[\"打游戏\",\"睡觉\"],\nsayHello:function(){\nconsole.log(\"hello\");\n}\n}\n\n代码分析：\n以上我们创建了一个对象叫做stu_xm，里面包含了\nname,age,sex,hobby,sayHello，5个属性，其中4个记录当前对象的特征，同\n时sayHello包含了一个方法描述了该对象的一种行为\n以上方式创建的对象，我们也可以叫字面量对象\n如果想再对象内部的方法中调用自己对象内部的属性，我们使用this变量，这\n个变量，现在先简单理解成，写在哪个对象里面，这个this就指向哪个对象"},"1":{"objectClass":"MindNode","ID":"PP528","children":{"0":{"objectClass":"MindNode","ID":"OYSOI","text":"通过Object方法创建 \nvar obj = new Object(); //这种情况下的对象是空对象，我们需要手动去给它添\n加属性"},"objectClass":"NSArray"},"text":"var stu_xm = {\nname:\"小明\",\nage:20,\nsex:\"男\",\nhobby:[\"打游戏\",\"睡觉\"],\nsayHello:function(){\nconsole.log(this.name + \"hello\");\n}\n}"},"objectClass":"NSArray"},"text":"对象的创建我们可以理解成对象的封装\n通过键值对创建对象\n\n\nvar 对象名 = {\nkey1:value1,\nkey2:value2,\nkey3:function(){\n}\n}"},"objectClass":"NSArray"},"text":"1、对象的定义"},"2":{"objectClass":"MindNode","ID":"12C07","children":{"0":{"objectClass":"MindNode","ID":"7P74L","children":{"0":{"objectClass":"MindNode","ID":"3GJ56","children":{"0":{"objectClass":"MindNode","ID":"M5DWH","text":"function createStudent(_name,_age,_sex){\nvar obj = {\nname:_name,\nage:_age,\nsex:_sex,\nsayHello:function(){\nconsole.log(\"大家好，我叫\" + this.name);\n}\n}\nreturn obj;\n}\nvar stu3 = createStudent(\"王五\",22,\"女\");\n\n代码分析：\n以上写法其实就是模仿了new关键字调用函数的特性，直接通过普通返回对象\n的方式模拟了new调用构造函数的作用，但是这写法无法确定原型"},"objectClass":"NSArray"},"text":"现在我们来写一个构造函数\n\nfunction Student(_name,_age,_sex){\nthis.name = _name;\nthis.age = _age;\nthis.sex = _sex;\nthis.sayHello = function(){\nconsole.log(\"大家好，我叫\" + this.name);\n}\n}\nvar stu1 = new Student(\"张三\",18,\"男\");\nvar stu2 = new Student(\"李四\",20,\"女\");"},"objectClass":"NSArray"},"text":"所有的构造函数在调用的时候都是使用new关键字来调用，并且构造函数的函数名\n首字母大写"},"objectClass":"NSArray"},"text":"2、使用构造函数创建对象（超级重点！！！！！）"},"3":{"objectClass":"MindNode","ID":"XNNIB","children":{"0":{"objectClass":"MindNode","ID":"AH434","children":{"0":{"objectClass":"MindNode","ID":"2CO4E","text":"1、构造函数使用new调用，普通函数直接使用函数名() 调用"},"1":{"objectClass":"MindNode","ID":"2F9R9","text":"2、构造函数的返回值一定是一个对象，而普通函数的返回值根据return决定"},"2":{"objectClass":"MindNode","ID":"Q875U","text":"3、普通函数的this它指向一个叫做window的对象，而构造函数的this指向的是创建\n的对象"},"3":{"objectClass":"MindNode","ID":"Z8552","text":"4、如果通过new的形式调用构造函数，在执行的时候，如果没有实参需要传入可以\n不写调用时的小括号"},"4":{"objectClass":"MindNode","ID":"LSG83","text":"5、构造函数的函数名首字母大写，普通函数的函数名我们使用小驼峰方式命名"},"objectClass":"NSArray"},"text":"构造函数和普通函数在书写上没有区别，关键在于调用上"},"objectClass":"NSArray"},"text":"3、构造函数与普通函数的区别"},"4":{"objectClass":"MindNode","ID":"ER1FS","children":{"0":{"objectClass":"MindNode","ID":"85F3Y","children":{"0":{"objectClass":"MindNode","ID":"64RI3","text":"var stu1 = {};\nObject.defineProperty(stu1,\"name\",{\n//关于特殊需求属性的定义\n})\n\n\n现在我们在对象stu1当中定义了一个name属性，现在它还是一个普通属性，现\n在我们来看下，我们可以设置属性的哪些行为描述"},"objectClass":"NSArray"},"text":"现在我们创建的对象，我们都叫基础对象，现在我们对对象有一些高级的需求，比\n如，一些特殊属性年龄，应该随着时间的增长而增长，类似这样的属性我们要怎么\n定义？\nObject.defineProperty() 定义对象属性"},"1":{"objectClass":"MindNode","ID":"M5M5U","children":{"0":{"objectClass":"MindNode","ID":"CRAMB","children":{"0":{"objectClass":"MindNode","ID":"4ECTX","text":"var stu = {\naaa:\"hello\"\n}\n//我们开始添加一个具备特殊行为描述的数据属性\nObject.defineProperty(stu,\"name\",{\nconfigurable:false, //表示不能被delete删除\nenumerable:false, //表示不能被for...in循环遍历到\nwritable:false, //不能修改值\nvalue:\"小芳\"\n})\nfor(var i in stu){\nconsole.log(i);\n}\n\n代码分析：\n现在我们给stu对象添加了一个name属性，对这个属性各种行为都设置了\nfalse，表示这个属性既不能被删除，也不能被修改，还不能被遍历到（像一些\n关键参数，我们就需要做这样的行为描述，避免被误修改）"},"objectClass":"NSArray"},"text":"数据属性就是一个包含一个数据的属性，我们可以在这个位置写入或者读取值，它\n有4个描述具体行为的特征：\n\n\nConfigurable：表示是否可以让delete关键字删除这个属性，它的默认值是true\nEnumerable：表示能否被for...in语句遍历到，这个默认值是true\nwritable：表示是否允许修改这个属性，默认是true\nvalue：包含了这个属性的数据值，默认是undefined"},"objectClass":"NSArray"},"text":"4.1、数据属性"},"2":{"objectClass":"MindNode","ID":"86YWA","children":{"0":{"objectClass":"MindNode","ID":"39G6L","children":{"0":{"objectClass":"MindNode","ID":"13K86","text":"Configurable：表示是否可以让delete关键字删除这个属性，它的默认值是true\nEnumerable：表示能否被for...in语句遍历到，这个默认值是true\nGet：在读取属性的时候调用的函数，默认值是undefined\nSet：在写入属性的时候调用的函数，默认值undefined\n"},"1":{"objectClass":"MindNode","ID":"1ED3Q","children":{"0":{"objectClass":"MindNode","ID":"15HI4","text":"上面的get和set所定义的age属性就是一个访问器属性，它在取值和赋值的时候会分\n别触发get和set方法\n接着，我们来看下访问器属性的具体作用："},"objectClass":"NSArray"},"text":"//现在有一个学生对象，我们在这个对象里面添加了一个数据属性birthday生日\n//现在我们希望再添加一个年龄age属性，但是这个age属性的值要根据生日来计算\nObject.defineProperty(stu,\"age\",{\nconfigurable:false, //表示不能被delete删除\nenumerable:true, //表示不能被for...in循环遍历到\nget:function(){\nreturn \"你正在读取age的属性\"\n},\nset:function(v){\n//v表示你赋的值\nconsole.log(\"你正在对这个age属性赋值，你要赋值的是\" + v);\n}\n})"},"objectClass":"NSArray"},"text":"访问器只能通过Object.defineProperty() 方法定义"},"objectClass":"NSArray"},"text":"4.2、访问器属性"},"3":{"objectClass":"MindNode","ID":"W65KV","children":{"0":{"objectClass":"MindNode","ID":"8163U","text":"var nameDesc = Object.getOwnPropertyDesciptor(stu,\"name\");\n//获取name属性的行为描述信息"},"objectClass":"NSArray"},"text":"4.3、获取对象特殊属性的描述信息"},"objectClass":"NSArray"},"text":"4、特殊需求属性"},"5":{"objectClass":"MindNode","ID":"L7KJI","children":{"0":{"objectClass":"MindNode","ID":"5ZJK9","children":{"0":{"objectClass":"MindNode","ID":"R5I14","children":{"0":{"objectClass":"MindNode","ID":"BW51N","text":"代码分析：\n以上代码中，我们首先创建了一个Person构造函数（模板），然后我们摒弃了\n之前的普通属性，改用defineProperties来设置特殊属性，让我们的构造函数\nnew出来的对象所具备属性，更加牢固"},"objectClass":"NSArray"},"text":"function Person(_name,_birthday,_IDCard){\nObject.defineProperties(this,{\nname:{\nconfigurable:false,\nwritable:false,\nvalue:_name\n},\nbirthday:{\nconfigurable:false,\nwritable:false,\nvalue:_birthday\n},\nsex:{\nconfigurable:false,\nget:function(){\nreturn this.IDCard[16] % 2 == 0 ? \"女\" : \"男\"\n}\n},\nage:{\nconfigurable:false,\nget:function(){\nvar cTime = new Date();\nvar bTime = new Date(this.birthday);\nvar total = cTime.getTime() - bTime.getTime();\nreturn parseInt(total / 1000 / 60 / 60 / 24 /\n365);\n}\n},\n\n\nIDCard:{\nconfigurable:false,\nwritable:false,\nvalue:_IDCard\n}\n})\n}\nvar p1 = new Person(\"张三\",\"2000-1-1\",\"420111200001010222\");"},"objectClass":"NSArray"},"text":"  构造函数与特殊属性的结合，主要指的就是构造函数与Object.defineProperties的\n结合，这里我们就可以在构造函数的体内直接定义特殊属性，通过这个构造new出\n来的对象（对象的实例化）属性就一直是一个经过特殊定义的属性"},"objectClass":"NSArray"},"text":"5、构造函数与特殊属性结合"},"6":{"objectClass":"MindNode","ID":"YTJJ8","children":{"0":{"objectClass":"MindNode","ID":"USE51","children":{"0":{"objectClass":"MindNode","ID":"I1YVQ","children":{"0":{"objectClass":"MindNode","ID":"XE7G0","text":"代码分析：\n这里我们通过对象的原型来实现了继承，对象的原型是在对象的一个叫做\n__proto__ 的属性中，而对象的原型我们可以认作对象的父级，所以当我们给\n这个属性赋值一个对象的时候，我们就认为一个对象具备了我们自己指定的父\n级，从而形成了父子关系，而父子关系的形成就意味着继承关系的形成，所以\n我们可以在new出来的对象中调用父级的属性和方法"},"objectClass":"NSArray"},"text":"function Person(_height){\nthis.height = _height;\nthis.sayHello = function(){\nconsole.log(\"大家好\")\n}\n}\nfunction Student(_userName,_sex,_age,_height){\nthis.userName = _userName;\nthis.age = _age;\nthis.sex = _sex;\nthis.__proto__ = new Person(_height);\n}\nvar s1 = new Student(\"张三\",\"男\",18,190);"},"objectClass":"NSArray"},"text":"现在我们通过控制台打印一个new出来的对象，在对象中找到一个属性 __proto__\n这个是对象的一个特殊属性，它指向的是对象的原型，我们可以把对象的原型理解\n成对象的父级\n通过原型来实现继承："},"objectClass":"NSArray"},"text":"6、对象的继承"},"7":{"objectClass":"MindNode","ID":"XE5VO","children":{"0":{"objectClass":"MindNode","ID":"AN334","children":{"0":{"objectClass":"MindNode","ID":"QCY75","text":"记住：this指向当前调用它的对象"},"1":{"objectClass":"MindNode","ID":"1OA1Q","text":"问题：这个当前对象到底是谁？\n1、在全局环境下，this指向的当前对象是window\n2、在自己定义的对象当中，this指向当前调用这个方法的对象"},"2":{"objectClass":"MindNode","ID":"Z8OFE","children":{"0":{"objectClass":"MindNode","ID":"06S3P","children":{"0":{"objectClass":"MindNode","ID":"W714N","text":"代码分析：\nvar s = stu.sayHello 相当于 window.s = stu.sayHello 所以接下来调\n用s（） 其实就是window.s()\n根据之前讲过的，对象方法里面的this指向调用这个方法的对象，现在这个方\n法被window对象调用，所以里面的this就指向window"},"objectClass":"NSArray"},"text":"var name = \"张三\";\nvar stu = {\nname:\"李四\",\nsayHello:function(){\nconsole.log(this.name); //stu.name\n}\n}\nvar s = stu.sayHello; //调出stu对象中的sayHello方法体赋值给变量s\n// s(){\n// console.log(this.name);\n// }\nwindow.s();"},"objectClass":"NSArray"},"text":"关于window对象\n之前我们在声明变量的时候通过var关键字声明变量，其实还可以理解成是\nwindow对象添加属性，通过function关键字声明的函数，其实就是给window\n对象添加方法，而直接添加在window对象下的属性和方法在调用的时候可以不\n写window对象自己"},"objectClass":"NSArray"},"text":"this是一个变量，也是一个指针，具体指向什么就看这个变量谁在调用它？\n对象中的this\n\nvar name = \"张三\";\nvar stu = {\nname:\"李四\",\nsayHello:function(){\nconsole.log(this.name); //stu.name\n}\n}\n\n上面的代码中，我们看到sayHello方法里面有个this，那么这个this指向谁？"},"objectClass":"NSArray"},"text":"7、this指针变量"},"8":{"objectClass":"MindNode","ID":"H20XV","children":{"0":{"objectClass":"MindNode","ID":"8FR1L","children":{"0":{"objectClass":"MindNode","ID":"Q2116","text":"构造函数与普通函数在本质上没有任何区别，关键在于其调用方式，用new调用的\n函数我们就叫做构造函数\n\nPerson() //window.Person(),所以这里的this指向window\nnew Person() //构造函数在调用的时候，体内的this指向的是当前实例化的对象"},"objectClass":"NSArray"},"text":"我们在构造函数里面也使用了this，它指向谁？\n\nvar name = \"haha\";\nfunction Person(){\nconsole.log(this.name);\n}"},"objectClass":"NSArray"},"text":"8、构造函数里面的 this"},"9":{"objectClass":"MindNode","ID":"LN3P4","children":{"0":{"objectClass":"MindNode","ID":"504OF","text":"函数的不同调用形式决定了this的指向\n先简单回顾下函数的调用方式：\nvar name = \"张三\";\nvar stu = {\nname:\"李四\",\nsayHello:function(){\nconsole.log(this.name); //stu.name\n}\n}\nvar s = stu.sayHello; //调出stu对象中的sayHello方法体赋值给变量s\n// s(){\n// console.log(this.name);\n// }\nwindow.s();\nvar name = \"haha\";\nfunction Person(){\nconsole.log(this.name);\n}\nPerson() //window.Person(),所以这里的this指向window\nnew Person() //构造函数在调用的时候，体内的this指向的是当前实例化的对象\n方法名()\nvar 方法名 = function(){}()\n!function(){}()\n(function(){})()\nnew function(){}\n除了上面5种之外，我们还有另外三种调用形式，这三种方式可以改变this指向"},"1":{"objectClass":"MindNode","ID":"4U466","children":{"0":{"objectClass":"MindNode","ID":"678DI","text":"var name = \"张三\";\nfunction sayHello(str){\nconsole.log(str);\nconsole.log(this.name);\n}\nvar stu1 = {\nname:\"李四\"\n}\nvar stu2 = {\nname:\"王五\"\n}\nsayHello(\"普通调用\") //window\nsayHello.call(stu1,\"我是通过call来调用的\");"},"objectClass":"NSArray"},"text":"9.1、通过call方法调用"},"2":{"objectClass":"MindNode","ID":"O62C9","children":{"0":{"objectClass":"MindNode","ID":"L8TK2","children":{"0":{"objectClass":"MindNode","ID":"CYTV4","text":"var name = \"张三\";\nfunction sayHello(str,x,y,z){\nconsole.log(str);\nconsole.log(x);\nconsole.log(this.name);\n}\nvar stu1 = {\nname:\"李四\"\n}\n\nvar stu2 = {\nname:\"王五\"\n}\nsayHello(\"普通调用\") //window\nsayHello.apply(stu2,[\"我是apply调用的\",1,2,3])"},"objectClass":"NSArray"},"text":"这个调用方式与call一模一样，唯一不同在于原来方法的参数上面"},"objectClass":"NSArray"},"text":"9.2、通过apply来调用"},"3":{"objectClass":"MindNode","ID":"0W67F","children":{"0":{"objectClass":"MindNode","ID":"804IV","children":{"0":{"objectClass":"MindNode","ID":"GE42P","children":{"0":{"objectClass":"MindNode","ID":"HMGY1","text":"var name = \"张三\";\nfunction abc(x,y){\nconsole.log(arguments);\nconsole.log(this.name,x,y)\n}\nvar stu1 = {\nname:\"李四\"\n}\nvar a = abc.bind(stu1,99,100);\na();\nvar b = abc.bind(stu1,200);\nb();\nvar c = abc.bind(stu1);\nc(500,600)"},"1":{"objectClass":"MindNode","ID":"V75RW","text":"var d = abc.bind(stu1,60,70);\nd(80,90);"},"objectClass":"NSArray"},"text":"var name = \"张三\";\nfunction abc(){\nconsole.log(this.name)\n}\nvar stu1 = {\nname:\"李四\"\n}\nvar x = abc.bind(stu1);\nx();"},"objectClass":"NSArray"},"text":"bind方法在调用方法的时候，不会立即执行原来的方法，而是返回一个新方法，通\n过新方法调用原方法"},"objectClass":"NSArray"},"text":"9.3、通过bind来调用"},"objectClass":"NSArray"},"text":"9、改变this指向"},"objectClass":"NSArray"},"text":"面向对象编程"},"1":{"objectClass":"MindNode","ID":"5FUK6","children":{"0":{"objectClass":"MindNode","ID":"9DWV1","children":{"0":{"objectClass":"MindNode","ID":"PV7B1","children":{"0":{"objectClass":"MindNode","ID":"394Q2","text":"在学习之前我们需要先简单一下：\ndocument是文档的意思，这个文档指向的就是当前网页\n页面上的所有元素（html），都会被JavaScript转换到JS中成为一个DOM对象\n如果是非IE浏览器，我们一般会根据一个id来生成一个对象，方便我们直接获取"},"objectClass":"NSArray"},"text":"DOM技术的本质其实就是操作我们的html元素进行各种操作\nDOM技术可以分为两个部分来理解：操作html，操作css"},"objectClass":"NSArray"},"text":"document object model 文档对象模型，主要作用就是把网页中的元素（标签+内\n容）当成一个JS对象来操作"},"1":{"objectClass":"MindNode","ID":"61E3S","children":{"0":{"objectClass":"MindNode","ID":"L04YK","text":"通过id来获取元素\n\nvar user = document.getElementById(\"user\");\n\n注意：\n因为是通过id获取，所以该方法永远至多只会获取到1个元素"},"1":{"objectClass":"MindNode","ID":"BN4N6","text":"通过class获取元素\n\ndocument.getElementsByClassName(\"类名\");\n\n这个方法会返沪i一个叫做HTMLCollection的集合（类数组），这个集合里面存\n放的都是DOM对象，如果没有获取到返回一个空数组"},"2":{"objectClass":"MindNode","ID":"O7N75","children":{"0":{"objectClass":"MindNode","ID":"KRF7F","children":{"0":{"objectClass":"MindNode","ID":"43RB2","text":"以上4种方式是我们最基础的4种获取元素的方式，这些方法兼容性好，在绝大部分\n浏览器里面都可以使用\n同时以上方法在使用时需要把获取id作为开头才能继续通过className或者\ntagName或者name来获取\n但是这是很早的解决方案，现在已经可以不需要使用了，转而另头新欢（强烈推\n荐）\n新的方法主要是结合了HTML5和CSS3的东西，我们直接把css选择器与JS做了结合"},"objectClass":"NSArray"},"text":"document.getElementsByName(\"name属性值\")\n\n这个方法返回的是一个叫做NodeList的集合，它也是个类数组"},"objectClass":"NSArray"},"text":"通过标签名获取元素\n\ndocument.getElementsByTagName(\"标签名\")\n\n这个方法会返沪i一个叫做HTMLCollection的集合（类数组），这个集合里面存\n放的都是DOM对象，如果没有获取到返回一个空数组"},"3":{"objectClass":"MindNode","ID":"B85XV","children":{"0":{"objectClass":"MindNode","ID":"GL621","text":"var div1 = document.querySelector(\"#div1\");\nvar box2 = document.querySelector(\".box2\");\n\n这种方法通过css选择器来获取元素，如果选中了就返回一个元素，找不到返回\nnull，如果找到多个值返回第一个"},"objectClass":"NSArray"},"text":"1、通过 querySelector(\"css选择器\") 获取元素"},"4":{"objectClass":"MindNode","ID":"R32HN","children":{"0":{"objectClass":"MindNode","ID":"V84BR","text":"var box2List = document.querySelectorAll(\"#div1>.box2\");\n\n这里返回的是一个NodeList的集合"},"objectClass":"NSArray"},"text":"2、通过 querySelectorAll(\"css选择器\") 来获取元素"},"objectClass":"NSArray"},"text":"1、通过JS获取页面元素"},"2":{"objectClass":"MindNode","ID":"BS88C","children":{"0":{"objectClass":"MindNode","ID":"786M6","text":"children：获取当前DOM对象内的所有子元素，返回一个集合\nparentElement：获取当前元素的父元素\nnextElementSibling : 当前元素的下一个兄弟\npreviousElementSibling：当前元素的上一个兄弟\n以上4个属性以当前元素为种获获取父级，子级，兄弟\nclassName：获取或者设置当前元素的class属性（类名）"},"objectClass":"NSArray"},"text":"2、Element常用属性和方法"},"3":{"objectClass":"MindNode","ID":"V57Q8","children":{"0":{"objectClass":"MindNode","ID":"UWL70","children":{"0":{"objectClass":"MindNode","ID":"2661V","text":"所谓事件，我们可以理解成用户对于浏览器和浏览器中允许的网页进行操作的一个\n动作，用户利用电脑的输入设备对网页上的元素进行各种操作，这些操作在\nJavaScript当中都有一个对应的事件，当用户执行这些操作的时候就会触发这些事\n件，而我们一般都会在这些事件上绑定一些方法，当用户执行某些操作就会触发这\n些事件，对应绑定在这些事件上面的方法就会被执行"},"1":{"objectClass":"MindNode","ID":"FH682","children":{"0":{"objectClass":"MindNode","ID":"S11I6","text":" <button type=\"button\" onclick=\"console.log('hello')\">按钮</button>\n<button type=\"button\" onclick=\"sayHello()\">方法</button>\n<script>\nfunction sayHello(){\nconsole.log(\"hello\")\n}\n</script>"},"1":{"objectClass":"MindNode","ID":"TBG78","text":"代码分析：\n用户触发了事件，事件调用了方法\n也就是说用户通过鼠标左键点击了button元素，触发了button元素身上的\nonclick事件，被触发的事件会调用该事件的事件方法"},"objectClass":"NSArray"},"text":"JavaScript是一个事件驱动的语言\n\n事件其实是以一个属性的形式存在的，而事件一定与某个标签进行强绑定的，所以\n事件可以作为标签属性也可以作为DOM对象属性来使用\nDOM可以产生交互的对象主要有两个\n页面元素\n系统（浏览器）\n事件其实就是DOM对象里面的一个特殊属性，它需要经过一个条件触发，与普通属\n性相比最大的区别就是属性值，事件作为一个属性它接收的值是一个function或者\n直接写一个执行语句也行"},"objectClass":"NSArray"},"text":"什么是事件？"},"1":{"objectClass":"MindNode","ID":"6S6IY","children":{"0":{"objectClass":"MindNode","ID":"34RH7","text":"0级事件本质上就是一个DOM对象的属性，只不过这个属性比较特殊\n1、属性值一般都是一个function\n2、这些事件属性的名称都是on开头\n在0级事件中，我们的事件又可以分为以下几个大类\n1、鼠标事件\n2、键盘事件\n3、文档事件\n4、其他事件"},"1":{"objectClass":"MindNode","ID":"81PQ4","children":{"0":{"objectClass":"MindNode","ID":"H3DV0","children":{"0":{"objectClass":"MindNode","ID":"215LI","text":"<button type=\"button\" onclick=\"console.log('hello')\">按钮</button>"},"objectClass":"NSArray"},"text":"第一种："},"1":{"objectClass":"MindNode","ID":"188PW","children":{"0":{"objectClass":"MindNode","ID":"LR35F","text":"<button type=\"button\" onclick=\"sayHello()\">方法</button>\n<script>\nfunction sayHello(){\nconsole.log(\"hello\")\n}\n</script>"},"objectClass":"NSArray"},"text":"第二种："},"2":{"objectClass":"MindNode","ID":"5O2SH","children":{"0":{"objectClass":"MindNode","ID":"3OX1T","text":"var btn = document.querySelector(\"#btn\");\nfunction sayHello(){\nconsole.log(\"hello\")\n}\nbtn.onclick = sayHello;"},"objectClass":"NSArray"},"text":"第三种：使用具名函数"},"3":{"objectClass":"MindNode","ID":"ENVT3","children":{"0":{"objectClass":"MindNode","ID":"8W2F7","text":"var btn = document.querySelector(\"#btn\");\nbtn.onclick = function(){\nconsole.log(\"hello\")\n}"},"objectClass":"NSArray"},"text":"使用匿名函数"},"4":{"objectClass":"MindNode","ID":"96BR1","children":{"0":{"objectClass":"MindNode","ID":"53Q33","text":"<ul>\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n</ul>\n<script>\nvar liList = document.querySelectorAll(\"li\");\nfor(var i = 0; i < liList.length;i++){\nliList[i].onclick = function(){\nthis.classList.toggle(\"active\")\n}\n}\n</script>"},"objectClass":"NSArray"},"text":"现在我们有个无序列表，我向给每一个列表项绑定一个点击事件，当点击当前li的时\n候改变当前li中的字体颜色，怎么实现？"},"objectClass":"NSArray"},"text":"1.1、事件绑定的方式"},"2":{"objectClass":"MindNode","ID":"1CA31","children":{"0":{"objectClass":"MindNode","ID":"821Q1","children":{"0":{"objectClass":"MindNode","ID":"8838L","text":"<button type=\"button\">0</button>\n<button type=\"button\">1</button>\n<button type=\"button\">2</button>\n<button type=\"button\">3</button>\n<button type=\"button\">4</button>\n<button type=\"button\">5</button>\n<button type=\"button\">6</button>\n<button type=\"button\">7</button>\n<button type=\"button\">8</button>\n<button type=\"button\">9</button>\n<script>\nvar btnList = document.querySelectorAll(\"button\");\nfor(var i = 0;i < btnList.length;i++){\nbtnList[i].onclick = function(){\nconsole.log(btnList[i].innerText);\n}\n}\n</script>"},"1":{"objectClass":"MindNode","ID":"P3Y42","text":"代码分析：\n以上写法是错误的，因为for循环已经执行完毕，i的值已经固定成了10，这个\n时候，当我们去触发事件，事件再调用方法的时候，方法里面的i 调用的值就是\n10，所以实际当你触发执行方法的时候，调用的 btnList[10]，但是集合里面没\n有索引为10的这个DOM对象，所以报错"},"2":{"objectClass":"MindNode","ID":"850F8","children":{"0":{"objectClass":"MindNode","ID":"3DWUQ","text":"var btnList = document.querySelectorAll(\"button\");\nfor(var i = 0;i < btnList.length;i++){\nbtnList[i].onclick = function(){\nconsole.log(this.innerText);\n}\n}"},"1":{"objectClass":"MindNode","ID":"5G297","text":"for(var i = 0;i < btnList.length;i++){\nbtnList[i].onclick = (function(j){\nreturn function(){\nconsole.log(btnList[j].innerText);\n}\n})(i)\n}"},"objectClass":"NSArray"},"text":"解决方案一：通过this"},"objectClass":"NSArray"},"text":"场景：现在页面上有10个按钮，我们希望对这个10个按钮绑定一个onclick事件，每\n个按钮点击的时候，在控制台打印当前那妞的序号，怎么实现？"},"objectClass":"NSArray"},"text":"1.2、0级事件批量绑定的注意事项"},"objectClass":"NSArray"},"text":"1、0级DOM事件"},"2":{"objectClass":"MindNode","ID":"RC2GD","children":{"0":{"objectClass":"MindNode","ID":"M5KO7","text":"事件对象是所有事件都具备的，当用户触发事件的时候，事件会调用方法，事件在\n调用事件方法的过程中会向该方法注入一个参数，这个参数就是一个事件对象event"},"1":{"objectClass":"MindNode","ID":"1V047","children":{"0":{"objectClass":"MindNode","ID":"NF7X0","text":"<div class=\"box\">事件对象</div>\n<script>\nvar box = document.querySelector(\".box\");\nbox.onclick = function(){\ne = event || window.event; //兼容写法，保障在不同浏览器中都可\n以正确获取到事件对象\n}\n</script>"},"objectClass":"NSArray"},"text":"2.1、获取事件对象"},"2":{"objectClass":"MindNode","ID":"7AOFN","children":{"0":{"objectClass":"MindNode","ID":"6G1XI","children":{"0":{"objectClass":"MindNode","ID":"7ET98","text":"<div class=\"box\">\n<button id=\"btn\">按钮</button>\n</div>\n<script>\nvar box = document.querySelector(\".box\");\nvar btn = document.querySelector(\"#btn\");\nbox.onclick = function(){\nconsole.log(\"我是box\");\n}\nbtn.onclick = function(){\nconsole.log(\"我是btn\");\n}\n</script>"},"1":{"objectClass":"MindNode","ID":"MN7NC","text":"代码分析：\n上面的代码中，我们点击box中的btn按钮的时候，我们发现两个事件都被触发\n了，这就说明了一点，内部按钮的onclick事件的行为传递给了外面元素box的\nonclick上面，这种现象我们叫做事件冒泡"},"2":{"objectClass":"MindNode","ID":"L4229","children":{"0":{"objectClass":"MindNode","ID":"BH1JW","text":"event.cancelBubble = true; //取消事件冒泡\nevent.stopPropagation(); //取消事件传播"},"objectClass":"NSArray"},"text":"取消事件冒泡"},"3":{"objectClass":"MindNode","ID":"D308T","children":{"0":{"objectClass":"MindNode","ID":"54ZC4","text":"var box = document.querySelector(\".box\");\nvar btn = document.querySelector(\"#btn\");\nbox.onclick = function(e){\ne = event || window.event;\nconsole.log(\"我是box\");\nconsole.log(\"target\",e.target);\nconsole.log(\"currentTarget\",e.currentTarget)\n}"},"1":{"objectClass":"MindNode","ID":"2TZ5H","text":"代码分析：\n上面的我们点击了btn，但是这个按钮本身是没有绑定事件，所以就算点击了这\n个按钮也不会有任何的触发，但是它会冒泡到外面的box上面，外面的box是绑\n定了事件的，导致btn的点击行为传播到了外面的box上面，因此触发了box身\n上的事件，那么，box的事件实际上是由btn触发的\n这里我们就理解成，btn是触发，box是绑定\ntarget是事件的触发者\ncurrentTarget是事件的绑定者"},"objectClass":"NSArray"},"text":"事件的触发者和绑定者"},"objectClass":"NSArray"},"text":"简单解释，一个DOM对象上面的事件会传播给另外一个DOM对象"},"objectClass":"NSArray"},"text":"2.2、事件传播"},"3":{"objectClass":"MindNode","ID":"V32T1","children":{"0":{"objectClass":"MindNode","ID":"44T7K","children":{"0":{"objectClass":"MindNode","ID":"TQ731","text":"代码分析：\n上面的代码，我们每添加一个新的li，都需要重新执行一边事件绑定，这样非常\n消耗性能，我们转换下思考方式，能不能把事件绑定到li的父级ul上，然后，让\n里面的元素通过事件冒泡来执行绑定在父元素上的事件方法"},"objectClass":"NSArray"},"text":"<button type=\"button\" onclick=\"addNewLi()\">添加列表项</button>\n<ul class=\"ul1\">\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n</ul>\n<script>\nfunction bindEvent(){\nvar liList = document.querySelectorAll(\".ul1>li\");\nfor(var i = 0; i < liList.length;i++){\nliList[i].onclick = function(){\nconsole.log(this.innerText);\n}\n}\n}\nbindEvent();\nfunction addNewLi(){\nvar newLi = document.createElement(\"li\"); //创建一个li\nnewLi.innerText = \"新增的项\"; //给新创建的li添加内容\n\ndocument.querySelector(\".ul1\").appendChild(newLi); //获取\nul，向内部的最后面添加一个li\nbindEvent(); //给新添加的列表项绑定事件\n}\n</script>"},"1":{"objectClass":"MindNode","ID":"I4Y6O","children":{"0":{"objectClass":"MindNode","ID":"P2K3X","children":{"0":{"objectClass":"MindNode","ID":"93G82","children":{"0":{"objectClass":"MindNode","ID":"1S2J6","text":"在DOM对象里面有个API方法，matches（）来完成判断"},"1":{"objectClass":"MindNode","ID":"Y6J87","text":"var ul1 = document.querySelector(\".ul1\");\nul1.onclick = function(e){\ne = event || window.event;\nif(e.target.matches(\"li.active\")){\nconsole.log(e.target.innerText);\n}\n}\nfunction addNewLi(){\n\nvar newLi = document.createElement(\"li\"); //创建一个li\nnewLi.innerText = \"新增的项\"; //给新创建的li添加内容\ndocument.querySelector(\".ul1\").appendChild(newLi); //获取ul，\n向内部的最后面添加一个li\n}"},"2":{"objectClass":"MindNode","ID":"4YBTY","text":"代码分析：\n这里使用的matches方法通过css选择器来指定元素，将指定好的元素的css选\n择器作为参数传入来指定触发者"},"objectClass":"NSArray"},"text":"现在我们想让指定的元素成为触发者，只有点击指定得到元素才会触发事件完成委\n托，那么现在需要判断触发者是否为指定元素"},"objectClass":"NSArray"},"text":"代码分析：\n上面的代码就是基本的事件委托代码，这个过程中onclick事件本来应该绑定在\nli身上的，但是现在委托给了ul进行绑定，然后利用事件冒泡的原理进行事件的\n传递（传播），传递给了外面的ul，这种现象我们就叫做事件委托"},"objectClass":"NSArray"},"text":"var ul1 = document.querySelector(\".ul1\");\nul1.onclick = function(e){\ne = event || window.event;\nconsole.log(e.target.innerText);\n}\nfunction addNewLi(){\nvar newLi = document.createElement(\"li\"); //创建一个li\nnewLi.innerText = \"新增的项\"; //给新创建的li添加内容\ndocument.querySelector(\".ul1\").appendChild(newLi); //获取ul，\n向内部的最后面添加一个li\n}"},"objectClass":"NSArray"},"text":"2.3、事件冒泡事件事件委托"},"objectClass":"NSArray"},"text":"2、事件对象event（重点）"},"3":{"objectClass":"MindNode","ID":"5332I","children":{"0":{"objectClass":"MindNode","ID":"O4T3B","children":{"0":{"objectClass":"MindNode","ID":"06T6H","text":"在上面的代码中，我们点击a标签的时候，它会执行onclick事件，然后再去执行a标\n签的跳转，这个a标签的跳转就是它的默认行为\n我们可以在事件当中取消某个元素的默认行为，只需要在事件方法的后面返回一个\nfalse即可\n\na1.onclick = function(){\nalert(\"hello world\");\nreturn false;\n}\n\n同样的其他一些自带默认行为的html标签也是一样处理，取消默认行为，比如重置\n按钮之类"},"objectClass":"NSArray"},"text":"有些标签在经过js的处理之后还会有一些响应，比如a标签\n<a href=\"https://www.baidu.com\">百度一下</a>\n<script>\nvar a1 = document.querySelector(\"a\");\na1.onclick = function(){\nalert(\"hello world\");\n}\n</script>"},"objectClass":"NSArray"},"text":"3、元素的默认行为"},"4":{"objectClass":"MindNode","ID":"V21XE","children":{"0":{"objectClass":"MindNode","ID":"78317","text":"2级事件是以监听的形式存在，使用以下三个方法来完成：\n1、addEventListener（） 添加事件监听\nvar newLi = document.createElement(\"li\"); //创建一个li\nnewLi.innerText = \"新增的项\"; //给新创建的li添加内容\ndocument.querySelector(\".ul1\").appendChild(newLi); //获取ul，\n向内部的最后面添加一个li\n}\n<a href=\"https://www.baidu.com\">百度一下</a>\n<script>\nvar a1 = document.querySelector(\"a\");\na1.onclick = function(){\nalert(\"hello world\");\n}\n</script>\na1.onclick = function(){\nalert(\"hello world\");\nreturn false;\n}\n2、dispatchEvent（）派发事件\n3、removeEventListener（） 移除事件监听"},"1":{"objectClass":"MindNode","ID":"LV185","children":{"0":{"objectClass":"MindNode","ID":"NX94C","children":{"0":{"objectClass":"MindNode","ID":"226WX","text":"简单举例：\n\n<button type=\"button\">按钮</button>\n<script>\nvar btn1 = document.querySelector(\"button\");\nfunction abc(e){\ne = event || window.event;\nconsole.log(e);\nconsole.log(this);\n}\nbtn1.addEventListener(\"click\",abc);\n</script>"},"1":{"objectClass":"MindNode","ID":"H12BQ","text":"也可以使用匿名的形式\n\nvar btn1 = document.querySelector(\"button\");\nbtn1.addEventListener(\"click\",function(e){\ne = event || window.event;\nconsole.log(e);\nconsole.log(this);\n});"},"2":{"objectClass":"MindNode","ID":"T2R24","text":"以上就是一个2级DOM事件，它是同监听的形式存在的，同时也可以向回调函\n数种注入一个事件对象event，并且this指向的是当前监听的DOM对象"},"objectClass":"NSArray"},"text":"DOM对象.addEventListener(\"需要监听的事件\",事件方法,Boolean);"},"objectClass":"NSArray"},"text":"4.1、添加2级事件监听"},"2":{"objectClass":"MindNode","ID":"T84R5","children":{"0":{"objectClass":"MindNode","ID":"HL69V","children":{"0":{"objectClass":"MindNode","ID":"8533M","children":{"0":{"objectClass":"MindNode","ID":"7F110","text":"代码分析：\n上面的代码里面，我们同时将2级事件和0级世家九年进行绑定，这个时候是不\n会报错的，它会优先执行0级事件，再去执行2级事件\n同时，2级事件可以实现多次监听"},"objectClass":"NSArray"},"text":"<button id=\"btn1\" onclick=\"console.log('我是行内代码')\">点我\n</button>\n<script>\nvar btn = document.querySelector(\"#btn1\");\n\nbtn.addEventListener(\"click\",function(){\nconsole.log(\"我是第一次2级事件\");\n})\nbtn.onclick = function(){\nconsole.log(\"我是一个0级事件\");\n}\nbtn.addEventListener(\"click\",function(){\nconsole.log(\"我是第二次监听2级事件\")\n})\n</script>"},"objectClass":"NSArray"},"text":"1、0级事件是以属性存在的，2级事件是以监听的形式存在的"},"1":{"objectClass":"MindNode","ID":"827TG","children":{"0":{"objectClass":"MindNode","ID":"2J3JC","children":{"0":{"objectClass":"MindNode","ID":"G8H83","text":"<div class=\"box\">\n<button id=\"btn\">按钮</button>\n</div>\n<script>\nvar box = document.querySelector(\".box\");\nvar btn = document.querySelector(\"#btn\");\nbox.addEventListener(\"click\",function(){\nconsole.log(\"box\");\nconsole.log(this);\n},true);\nbtn.addEventListener(\"click\",function(){\nconsole.log(\"btn\");\nconsole.log(this);\n},true)\n</script>"},"1":{"objectClass":"MindNode","ID":"RH5Q2","text":"代码分析：\n在addEventListener的第三个参数，这个参数可选，如果不写默认false表示执\n行事件冒泡，如果参数为true则执行事件捕获"},"objectClass":"NSArray"},"text":"之前学习0级事件的时候，0级事件的传播方向是由内向外进行冒泡传播，这个方向\n是不可逆的，但是2级事件里面，这个方向可以改变"},"objectClass":"NSArray"},"text":"2、0级事件都是on开头，2级事件在监听的时候去掉了on\n3、0级事件不可以改变事件传播的方向，2级事件是可以的"},"2":{"objectClass":"MindNode","ID":"115KP","text":"4、0级事件如果要取消，需要给当前事件属性赋值为null，2级事件需要使用\nremoveEventListener方法来完成"},"objectClass":"NSArray"},"text":"4.2、2级事件与0级事件的区别"},"objectClass":"NSArray"},"text":"4、2级事件"},"5":{"objectClass":"MindNode","ID":"7M2LE","children":{"0":{"objectClass":"MindNode","ID":"3DS14","children":{"0":{"objectClass":"MindNode","ID":"Z2ZRH","text":"如果我们希望某一个监听的方法只被执行一次，怎么写？\n\n<button id=\"btn\">按钮</button>\n<script>\nvar btn = document.querySelector(\"#btn\");\nbtn.addEventListener(\"click\",function(){\nconsole.log(\"我是一个按钮\");\nthis.removeEventListener(event.type,arguments.callee);\n})\n</script>"},"1":{"objectClass":"MindNode","ID":"94XTC","text":"代码分析：\nevent.type指的是当前事件的类型名称，arguments.callee 指向当前函数的引\n用，也就是当前函数本身"},"objectClass":"NSArray"},"text":"<div class=\"box\">我是一个盒子</div>\n<button id=\"btn\">移除box的点击事件</button>\n<script>\nvar box = document.querySelector(\".box\");\nvar btn = document.querySelector(\"#btn\");\nbox.addEventListener(\"click\",a);\nfunction a(){\nconsole.log(\"我是一个box\",this);\n}\nbox.addEventListener(\"click\",b);\nfunction b(){\nconsole.log(\"我是第二个box\")\n}\n//给btn添加一个监听，当点击btn元素的时候，执行监听的回调\nbtn.addEventListener(\"click\",function(){\n//移除box中点击执行的a方法\nbox.removeEventListener(\"click\",a);\n})\n</script>"},"objectClass":"NSArray"},"text":"5、移除2级事件监听"},"6":{"objectClass":"MindNode","ID":"P70X8","children":{"0":{"objectClass":"MindNode","ID":"14F7Y","text":"在0级事件中我们需要在事件方法内return false 来取消默认行为，在2级事件中需要\n使用到事件对象中的一个方法"},"1":{"objectClass":"MindNode","ID":"3SHB2","children":{"0":{"objectClass":"MindNode","ID":"P6GTQ","text":"代码分析：\n在2级事件中需要通过事件对象中的preventDefault方法来阻止事件的默认行为"},"objectClass":"NSArray"},"text":"<a href=\"https://www.baidu.com\">百度以下</a>\n<script>\nvar a1 = document.querySelector(\"a\");\na1.addEventListener(\"click\",function(){\nalert(\"我是2级事件\");\nevent.preventDefault();\n})\n</script>"},"objectClass":"NSArray"},"text":"6、阻止事件的默认行为"},"7":{"objectClass":"MindNode","ID":"X2VV6","children":{"0":{"objectClass":"MindNode","ID":"4Y7M6","text":"2级事件是可以多次监听的，那么，多次监听会形成一个事件链，我们可以断开这个\n事件链"},"1":{"objectClass":"MindNode","ID":"VJ2H3","text":"<button id=\"btn\">按钮</button>\n<script>\nvar btn = document.querySelector(\"#btn\");\nbtn.addEventListener(\"click\",function(){\nconsole.log(\"第一次\");\n})\nbtn.addEventListener(\"click\",function(){\nconsole.log(\"第二次\");\n})\nbtn.addEventListener(\"click\",function(){\nconsole.log(\"第三次\");\nevent.stopImmediatePropagation(); //断开事件链\n})\nbtn.addEventListener(\"click\",function(){\nconsole.log(\"第四次\");\n})\nbtn.addEventListener(\"click\",function(){\nconsole.log(\"第五次\");\n})\n</script>"},"objectClass":"NSArray"},"text":"7、断开事件链"},"objectClass":"NSArray"},"text":"DOM事件"},"objectClass":"NSArray"},"text":"DOM"},"objectClass":"NSArray"},"text":"面向对象编程和DOM"},"ID":"355M5","style":100,"lineKeepThin":true}