<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <dateModified></dateModified>
    <ownerName></ownerName>
  </head>
  <body>
<outline text="&lt;strong&gt;nodeJS&lt;/strong&gt;" _note="简单来说就是JavaScript在服务器上的运行环境&#10;&#10;我们之前在学习JavaScript的时候有这么一个概念，JavaScript是运行在浏览器上面的，它必须依托HTML才能存在，没有网页的存在就没有JS的执行，&#10;所以我们认为浏览器和HTML就分别是JavaScript在客户端中运行的平台和环境，但是后期人们把运行在浏览器中的chorme&#10;V8移植到了服务器里，这样就可以保障我们的JS代码可以在服务器端运行，而不需要依赖浏览器和网页了&#10;&#10;&gt; 注意：&#10;&gt;&#10;&gt; node中只有ES，没有DOM和BOM">
  <outline text="1、nodeJS基础" _note="安装好之后，可以在命令行终端输入 node&#10;-v查看，如果显示了版本号就说明安装成\&#10;功\&#10;安装成功之后，我们如果想允许一个JS文件非常简单，一个指令&#10;&#10;``` powershell&#10;node 文件名.js //node指令后面其实是一个路径指向一个需要执行的JS文件&#10;```&#10;&#10;在node中不能允许DOM和BOM，只能允许ECMAScript&#10;&#10;``` powershell&#10;window.alert(&quot;a&quot;); //报错，因为window是BOM中提供的对象，不能在node中使用&#10;```">
  </outline>
  <outline text="2、CommonJS模块化开发" _note="之前我们在学习ES6+的时候，使用的是ESModule的模块化规范，这是ES的通用规范，基本上90%以上使用到JS的地方都是遵循这个规范，但是node就不是的，它执行的是CommonJS规范&#10;&#10;&gt; **模块化开发现行规范**&#10;&gt;&#10;&gt; 1、浏览器及ECMA执行的是通用规范ESModule&#10;&gt;&#10;&gt; 2、nodeJS平台使用的是CommonJS&#10;&#10;  **规范**   **导入**    **导出**&#10;  ---------- ----------- ----------------&#10;  ESModule   import      export default&#10;  CommonJS   require()   module.exports">
  </outline>
  <outline text="3、CommonJS的模块导入" _note="现在有以下文件&#10;&#10;a.js&#10;&#10;``` javascript&#10;console.log(&quot;我是a文件&quot;)&#10;```&#10;&#10;b.js&#10;&#10;``` javascript&#10;console.log(&quot;我是b文件&quot;);&#10;require(&quot;./a.js&quot;) //console.log(&quot;我是a文件&quot;)&#10;require(&quot;./a.js&quot;) //console.log(&quot;我是a文件&quot;)&#10;require(&quot;./a.js&quot;) //console.log(&quot;我是a文件&quot;)&#10;require(&quot;./a.js&quot;) //console.log(&quot;我是a文件&quot;)&#10;require(&quot;./a.js&quot;) //console.log(&quot;我是a文件&quot;)&#10;require(&quot;./a.js&quot;) //console.log(&quot;我是a文件&quot;)&#10;```&#10;&#10;当我们多次导入的时候，我们发现最终a.js的代码只执行了一次&#10;&#10;require方法导入一个模块之后，它会这个模块缓存下来，下在再导入的时候，则直接从缓存里面拿，在上面的代码中，表面上看起来是导入了6次，但是实际上只有第一次导入是真的导入了，剩下的5次全部都是从缓存里面拿的">
  </outline>
  <outline text="4、CommonJS的模块导出" _note="导入和导出其实是一对，所以在node中如果我们导出可以使用以下两个方式&#10;&#10;1、module.exports 直接导出&#10;&#10;2、exports 指针导出&#10;&#10;a.js&#10;&#10;``` javascript&#10;let userName = 123;&#10;module.exports = userName;&#10;```&#10;&#10;b.js&#10;&#10;``` javascript&#10;const userName = require('./a.js');&#10;console.log(userName);&#10;```&#10;&#10;以上完成了一个基础的导入导出&#10;&#10;在CommonJS规范中，每个文件都会专门用于导出的属性叫做module.exports，而&#10;&#10;在require中导入的实际上module.exports">
    <outline text="4.1、module.exports" _note="在每个文件里面都会有一个负责导出的对象，module.exports，如果我们直接打印&#10;&#10;这个对象我们会看到一个空对象&#10;&#10;``` javascript&#10;let userName = 123;&#10;let age = 20;&#10;let obj = {&#10;userName,&#10;age&#10;}&#10;module.exports = obj;&#10;```&#10;&#10;如果我们有多个变量需要同时导出，我们可以把这个变量封装成对象，然后导出&#10;&#10;b.js&#10;&#10;``` javascript&#10;const {userName,age} = require('./a.js'); //ES6解构导入&#10;console.log(userName);&#10;```">
    </outline>
    <outline text="4.2、exports" _note="在CommonJS当中，真正负责导出的只有module.exports，但是还有一个指针可以&#10;&#10;指向这个module.exports&#10;&#10;``` javascript&#10;module.exports === exports&#10;```&#10;&#10;a.js&#10;&#10;``` javascript&#10;let userName = 123;&#10;let age = 20;&#10;module.exports = userName;&#10;exports = age;&#10;```&#10;&#10;b.js&#10;&#10;``` javascript&#10;const abc = require('./a.js');&#10;console.log(abc);&#10;```&#10;&#10;上面的代码中，既有module.exports，又有exports，那么b里面到底导入的是谁？&#10;&#10;始终记住一句话，真正负责导入的是 module.exports ，所以结果是userName">
    </outline>
  </outline>
  <outline text="5、node平台的模块化功能" _note="node是一个运行平台，与浏览器一样用于运行JS，同理在弄得、上面，它会内置一些模块提供给我们使用">
    <outline text="5.1、path模块" _note="path模块是node平台子代的模块化开发中使用的一个内置模块，遵循CommonJS的模块化开发规范&#10;&#10;``` javascript&#10;__dirname //代表当前JS文件所属的文件夹所在目录的路径&#10;__filename //代表当前JS文件的路径&#10;```&#10;&#10;以上两个内置变量是node平台上面的最基础的两个点，也是经常会使用到的变量，\&#10;这两个变量负责路径\&#10;其中关于路径的处理，nodeJS平台有专门的模块去处理，这个模块就是path模块，\&#10;它不用下载，在安装nodeJS的时候就已经自带了&#10;&#10;``` javascript&#10;const path = require(&quot;path&quot;)&#10;```&#10;&#10;``` javascript&#10;const path = require(&quot;path&quot;)&#10;//1、join方法路径拼接&#10;let p1 = path.join(__dirname,'/txt');&#10;console.log(p1);&#10;//2、extname方法，获取某个路径的后缀名、&#10;let p2 = path.extname(__filename);&#10;console.log(p2);&#10;//3、isAbsolute方法，判断是否是绝对路径&#10;let p3 = path.isAbsolute(__dirname);&#10;console.log(p3);&#10;//4、resolve方法，将相对路径转换成绝对路径&#10;let p4 = path.resolve(&quot;./txt/abc.txt&quot;);&#10;console.log(p4);&#10;```">
    </outline>
    <outline text="5.2、fs模块" _note="一般我们有了路径之后，就会有文件，我们可以通过某一个路径找到某一个文件或者目录，在node当中有一个专门用来读写文件的模块就是FS模块（flie&#10;system）&#10;&#10;``` javascript&#10;&#10;&#10;const path = require(&quot;path&quot;);&#10;&#10;const fs = require(&quot;fs&quot;);&#10;//1、fs.existsSync() 判断路径是否存在&#10;let p1 = path.join(__dirname,&quot;/txt/abc.txt&quot;);&#10;let result = fs.existsSync(p1);&#10;console.log(result);&#10;//2、fs.rmdirSync() 删除空文件夹，如果删除的不是空文件夹会报错&#10;let p2 = path.join(__dirname,&quot;/img&quot;);&#10;if(fs.existsSync(p2)){&#10;fs.rmdirSync(p2);&#10;}else{&#10;console.log(&quot;这个文件夹路径不存在&quot;)&#10;}&#10;//3、fs.unlinkSync() 根据路径删除文件&#10;let p3 = path.join(__dirname,'/txt/abc.txt');&#10;if(fs.existsSync(p3)){&#10;fs.unlinkSync(p3)&#10;}else{&#10;console.log(&quot;这个文件不存在&quot;)&#10;}&#10;//4、fs.copyFileSync(oldPath,newPath) 复制文件&#10;let oldPath = path.join(__dirname,&quot;/txt/abc.txt&quot;);&#10;let newPath = path.join(__dirname,&quot;/123/abc.txt&quot;);&#10;fs.copyFileSync(oldPath,newPath);&#10;//5、fs.renameSync(oldPath,newPath) 文件重命名&#10;let oldPath = path.join(__dirname,&quot;/txt/abc.txt&quot;);&#10;let newPath = path.join(__dirname,&quot;/txt/123.txt&quot;);&#10;fs.renameSync(oldPath,newPath);&#10;//6、fs.mkdirSync() 根据路径创建文件夹&#10;let p6 = path.join(__dirname,&quot;/css&quot;);&#10;if(fs.existsSync(p6)){&#10;console.log(&quot;当前路径已经存在&quot;)&#10;}else{&#10;fs.mkdirSync(p6);&#10;}&#10;//7、fs.readdirSync() 读取某一个路径下的文件夹内部信息&#10;let arr = fs.readdirSync(__dirname + &quot;/txt&quot;);&#10;console.log(arr);&#10;```&#10;&#10;1.  fs.statSync() 读取路径状态&#10;&#10;``` javascript&#10;let sta = fs.statSync(__dirname + &quot;/txt&quot;);&#10;console.log(sta);&#10;sta.isFile() //判断是否是文件路径&#10;sta.isDirectory() //判断是否是文件夹路径&#10;```&#10;&#10;9、fs.readFileSync() 通过路径读取路径指向文件的内部内容&#10;&#10;``` javascript&#10;let result = fs.readFileSync(__dirname + &quot;/123/abc.txt&quot;,{&#10;encoding:&quot;utf8&quot;&#10;})&#10;console.log(result);&#10;```&#10;&#10;10、fs.writeFileSync() 把内容写入一个文件&#10;&#10;``` javascript&#10;let str = `今天天气不错`;&#10;fs.writeFileSync(__dirname + &quot;/123/abc.txt&quot;,str,&#10;{encoding:&quot;utf8&quot;})&#10;```">
    </outline>
  </outline>
</outline>
  </body>
</opml>
